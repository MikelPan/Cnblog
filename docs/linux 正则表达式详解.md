## 前言
对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。

其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。

0\d{2}-\d{8}|0\d{3}-\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。

### 什么是正则表达式
正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。

## 正则字符简单介绍
### 元字符介绍
```bash
"^": ^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置.

"$": $会匹配行或字符串的结尾.

"\b": 不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中"This is Regex"匹配单独的单词 "is" 正则就要写成 "\bis\b",\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界.

"\d": 匹配数字，例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123,正则:^0\d\d\d-\d\d\d\d\d\d\d$.

"\w": 匹配字母，数字，下划线,例如我要匹配"a2345BCD__TTz" 正则："\w+",这里的"+"字符为一个量词指重复的次数.

"\s": 匹配空格,例如字符 "a b c" 正则："\w\s\w\s\w"  一个字符后跟一个空格，如有字符间有多个空格直接把"\s" 写成 "\s+" 让空格重复.

".": 匹配除了换行符以外的任何字符,这个算是"\w"的加强版了"\w"不能匹配空格,如果把字符串加上空格用"\w"就受限了，看下用"."是如何匹配字符"a23 4 5 B C D__TTz"  正则：".+"

"[abc]": 字符组,匹配包含括号内元素的字符 
```
### 几种反义
```bash
"\W"      匹配任意不是字母，数字，下划线 的字符
"\S"      匹配任意不是空白符的字符
"\D"      匹配任意非数字的字符
"\B"      匹配不是单词开头或结束的位置
"[^abc]"  匹配除了abc以外的任意字符
```
###  量词
贪婪(贪心),如"*"字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的.

懒惰(勉强),如 "?"  懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处.

占有,如"+" 占有量词会覆盖事个目标字符串,然后尝试寻找匹配内容,但它只尝试一次,不会回溯,就好比先抓一把石头,然后从石头中挑出黄金.

"*"(贪婪): 重复零次或更多,例如"aaaaaaaa",匹配字符串中所有的a,正则: "a*",会出到所有的字符"a"

"+"(懒惰): 重复一次或更多次,例如"aaaaaaaa" 匹配字符串中所有的a,正则: "a+",会取到字符中所有的a字符,"a+"与"a*"不同在于"+"至少是一次而"*" 可以是0次.

"?"(占有): 重复零次或一次,例如"aaaaaaaa" 匹配字符串中的a,正则: "a?",只会匹配一次，也就是结果只是单个字符a.

"{n}": 重复n次,例如从"aaaaaaaa" 匹配字符串的a 并重复3次,正则: "a{3}"结果就是取到3个a字符"aaa";

"{n,m}": 重复n到m次,例如正则 "a{3,4}" 将a重复匹配3次或者4次,所以供匹配的字符可以是三个"aaa"也可以是四个"aaaa" 正则都可以匹配到.

"{n,}": 重复n次或更多次,与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则"a{3,}",a至少要重复3次

### 懒惰限定符
"*?": 重复任意次，但尽可能少重复,例如"acbacb",正则"a.*?b" 只会取到第一个"acb" 原本可以全部取到但加了限定符后,只会匹配尽可能少的字符,而"acbacb"最少字符的结果就是"acb".

"+?": 重复1次或更多次，但尽可能少重复,与上面一样，只是至少要重复1次

"??": 重复0次或1次，但尽可能少重复,例如 "aaacb" 正则 "a.??b" 只会取到最后的三个字符"acb"

"{n,m}?": 重复n到m次，但尽可能少重复,例如 "aaaaaaaa" 正则 "a{0,m}" 因为最少是0次所以取到结果为空

"{n,}?": 重复n次以上，但尽可能少重复,例如 "aaaaaaa"  正则 "a{1,}" 最少是1次所以取到结果为"a".

## grep 正则表达式
grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。

Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。

### grep常用用法
```bash
grep [-acinv] [--color=auto] '搜寻字符串' filename
选项与参数：
-a ：将 binary 文件以 text 文件的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto ：可以将找到的关键词部分加上颜色的显示喔！
```

## sed 正则表达式

### sed 用法
```bash
# 批量替换
sed -i "s/oldstring/newstring/g" grep oldstring -rl path
```

## awk 正则表达式

### awk用法
```bash
# 统计数据
cat xx.log |awk '{a[$1]+=1;} END {for(i in a){print a[i]" "i;}}'
#字符串截取
echo "123456789" | awk '{print substr($0, 5, 2)}'
```
